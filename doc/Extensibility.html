<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type"
        content="text/html; charset=us-ascii" />

  <title>Extensibility</title>
  <link rel="stylesheet"
        type="text/css"
        media="screen"
        href="JPF_files/JPF-mod.css" />
  <base target="_blank" />
</head>

<body>
  <h1>Extensibility</h1>

  <p>From the list of JPF features mentioned above, it should be
  clear that the system is not a classical model checker anymore.
  One can think of JPF as an execution system framework for all
  kinds of dynamic, runtime oriented verification purposes. JPF
  tries to overcome the systematic scalability problem of software
  model checking by application- and property- specific adaptation.
  As a consequence, the major design force driving it's further
  development is extensibility. This document includes descriptions
  of three major extension mechanisms: (1) Search-/VMListeners and
  (2) Model Java Interface (MJI) and (3) Configurable ChoiceGenerators.</p>

  <p><b>(1) <a href="Search-_and_VMListeners.html" target="content">Search-
  /VMListeners</a></b> provide a convenient way to extend JPFs internal state
  model, add more complex property checks, direct searches, or simply gather
  execution statistics. This is achieved by an Observer pattern that lets
  concrete observers (listeners) subscribe to certain events inside JPF,
  like bytecode instruction execution or forward/backtrack
  steps.</p>

  <p><b>(2) <a href="The_Model_Java_Interface.html" target="content">The Model
  Java Interface</a></b> (MJI) is a mechanism to separate and communicate
  between state-tracked execution inside the JPF JVM, and non-state tracked
  execution inside the underlying host VM (executing JPF itself). This can be
  used to build standard library abstractions that significantly reduce the
  application state space.</p>
  
  <p><b>(3) <a href="ChoiceGenerators.html" target="content">Configurable
  ChoiceGenerators</a></b> (CGs) are used to implement application specific
  heuristics for "non-deterministic" data acquisition and scheduling policies,
  without the need to modify test drivers. ChoiceGenerators can be specified and
  parameterized via the normal JPF configuration mechanism, and used from
  within MJI native methods and Listeners.</p>
  
</body>
</html>
